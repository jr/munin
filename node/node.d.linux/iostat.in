#!@@PERL@@ -w
#
# Plugin for watching io-bound traffic (in blocks) on disks.
#
# Usage: Link or copy into /etc/munin/node.d/
#
# Parameters:
#
# 	config   (required)
# 	autoconf (optional - used by munin-config)
#
# $Log$
# Revision 1.1  2004/01/02 18:50:01  jimmyo
# Renamed occurrances of lrrd -> munin
#
# Revision 1.1.1.1  2004/01/02 15:18:07  jimmyo
# Import of LRRD CVS tree after renaming to Munin
#
# Revision 1.5  2003/12/18 18:09:32  jimmyo
# Added total line
#
# Revision 1.4  2003/12/18 11:01:51  jimmyo
# Fix by_dev compare issue.
#
# Revision 1.3  2003/12/16 17:51:08  jimmyo
# Plugin linux/iostat modified. Now runs on 2.6, and now "mirrors" i/o like eth* et al. (Deb#224113, Deb#223373)
#
# Revision 1.2  2003/11/07 17:43:16  jimmyo
# Cleanups and log entries
#
#
#
# Magic markers (optional - used by munin-config and some installation
# scripts):
#
#%# family=auto
#%# capabilities=autoconf

use strict;


if ( $ARGV[0] and $ARGV[0] eq "autoconf")
{
	if (system("grep -q '^disk_io: [^ ]' /proc/stat") == 0)
	{
		print "yes\n";
		exit 0;
	}
	else
	{
		if (system ("iostat >/dev/null 2>&1") == 0)
		{
			print "yes\n";
			exit 0;
		}
		print "no\n";
		exit 1;
	}
}

open (IN, "/proc/stat") or die "Could not open /proc/stat for reading: $!\n";

my %devs = ();

while (<IN>)
{
	next unless (/^disk_io:\s*(.+)\s*/);
	foreach my $dev (split /\s+/)
	{
		next unless $dev =~ /\S/;
		next unless ($dev =~ /\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)/);
		$devs{"dev".$1."_".$2} = [$3, $4];
	}
}

close (IN);

if (! %devs)
{
    # Falling back to iostat
	if (open (IOSTAT, "iostat|"))
	{
		my $devs = 0;
		while (<IOSTAT>)
		{
			if (/^Device/)
			{
				$devs++;
			}
			elsif ($devs)
			{
				next unless /\S/;
				my @fields = split (/\s+/, $_);
				$fields[0] =~ s/-/_/;
				$devs{$fields[0]} = [$fields[4], $fields[5]];
			}
		}
		close (IOSTAT);
	}
}

if ( $ARGV[0] and $ARGV[0] eq "config")
{

	print "graph_title IOstat\n";
	print "graph_args --base 1024 -l 0\n";
	print "graph_vlabel blocks written (-) read (+) / second\n";
	print "graph_total Total\n";
	print "graph_order";
	foreach my $key (sort by_dev keys %devs)
	{
		print " ", $key, "_write ", $key, "_read";
	}
	print "\n";
	foreach my $key (sort by_dev keys %devs)
	{
		print $key . "_write.label $key\n";
		print $key . "_write.type COUNTER\n";
		print $key . "_write.max 10000\n";
		print $key . "_write.graph no\n";
		print $key . "_read.label $key\n";
		print $key . "_read.type COUNTER\n";
		print $key . "_read.max 10000\n";
		print $key . "_read.negative " . $key . "_write\n";
	}
	exit 0;
}

foreach my $key (sort by_dev keys %devs)
{
	print $key, "_write.value ", $devs{$key}->[1], "\n";
	print $key, "_read.value ", $devs{$key}->[0], "\n";
}

sub by_dev {
	return $a cmp $b;
}

# vim:syntax=perl
