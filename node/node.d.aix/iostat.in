#!@@PERL@@ -w
#
# $Log$
# Revision 1.3  2004/12/10 10:47:49  jimmyo
# Change name from ${scale} to ${graph_period}, to be more consistent.
#
# Revision 1.2  2004/12/09 22:12:55  jimmyo
# Added "graph_period" option, to make "graph_sums" usable.
#
# Revision 1.1  2004/01/02 18:50:00  jimmyo
# Renamed occurrances of lrrd -> munin
#
# Revision 1.1.1.1  2004/01/02 15:18:07  jimmyo
# Import of LRRD CVS tree after renaming to Munin
#
# Revision 1.2  2003/11/07 17:43:16  jimmyo
# Cleanups and log entries
#
#
#
# Plugin for watching io-bound traffic (in KiloBytes) on disks.
#
#   DESCRIPTION
#   ===========
#     This version of iostat will report back the amount of I/O on a per
#     disk basis.  It includes the vpaths in it's report.  The I/O for a
#     vpath is the sum of the reads/writes of all the hdisks assosciated
#     with it.  It uses /usr/bin/iostat.  
#     
#   RESTRICTIONS
#   ============
#     Not restricted to a particular user.  You will have to enable disk accounting for this to
#     work correctly.  You can do this through 'smitty chgsys -> Continuously maintain DISK I/O history',
#     change this to true, or you can do it at the command line with this command
#     "chdev -l sys0 -a iostat='true'".
#
# Note:  If you have virtual paths, typical when gigabit fiber cards
#        are installed and attached to an ESS (Shark) or some sort of
#        large disk array, this will combine the I/O for all hdisks
#        associated with a vpath so you get global statistics for a 
#        vpath.  This is to avoid having a list of hdisks that spans
#        multiple pages.
#
# Usage: Link or copy into /etc/munin/node.d/
#
# Parameters:
#
# 	config   (required)
# 	autoconf (optional - used by munin-config)
#
# Magic markers (optional - used by munin-config and some installation
# scripts):
#
#%# family=contrib
#%# capabilities=autoconf

use strict;
use POSIX;

my($arg) = shift;

if($arg && $arg eq "autoconf")
  {
    if((-e "/usr/bin/iostat" && -X "/usr/bin/iostat") && (-e '/usr/sbin/lspv' && -X '/usr/sbin/lspv'))
      {
        print "yes\n";
        exit 0;
      }
    else
      {
        print "no\n";
        exit 1;
      }
  }
 
if($arg && $arg eq "config")
  {
    print "graph_title IOstat\n";
    print "graph_args --base 1024 -l 0\n";
    print "graph_vlabel KB / ${graph_period}\n";
    my(@info) = getDiskIO("disk only");
    my($line);
    foreach $line (@info)
      {
        print "$line.label $line\n";
        print "$line.type COUNTER\n";
        print "$line.max 100000\n";
      }
    exit 0;
  }
  
my(@info) = getDiskIO('');
my($line);
foreach $line (@info)
  {print "$line";}
@info = processVPaths();
foreach $line (@info)
  {print "$line";}
  
    
sub getDiskIO
{
  my($diskOnly) = @_;
  my($line,@lineArray,@diskArray,$writes,$reads,$diskLine);
  if($diskOnly && $diskOnly eq 'disk only')
    {
      open DISKLIST, "/usr/sbin/lspv|egrep 'hdisk|vpath'|grep -v none|";
      while($line = <DISKLIST>)
        {
          @lineArray = split(/ +/,$line);
          push(@diskArray,"$lineArray[0]_read","$lineArray[0]_write");
        }
    }
  else
    {
      open DISKLIST, "/usr/sbin/lspv|grep hdisk|grep -v none|";
      while($line = <DISKLIST>)
        {
          @lineArray = split(/ +/,$line);
          $diskLine = `/usr/bin/iostat|grep $lineArray[0]`;
          @lineArray = split(/ +/,$diskLine);
          $writes = $lineArray[5];
          chomp($writes);
          $reads = $lineArray[4];
          chomp($reads);
          
          push(@diskArray,"$lineArray[0]_read.value $reads\n","$lineArray[0]_write.value $writes\n");
        }
    }
  return @diskArray
}

sub processVPaths
{
  open DISKLIST, "/usr/sbin/lspv|grep vpath|";
  my($line,$hdiskLine,@diskArray,$reads,$writes);
  while($line = <DISKLIST>)
    {
      my(@vpathArr) = split(/ +/,$line);
      my($vpathNum) = substr($vpathArr[0],index($vpathArr[0],"h")+1);
      open VPATHINFO, "/usr/bin/datapath query device $vpathNum|grep hdisk|";
      $reads = 0;
      $writes = 0;
      while($hdiskLine = <VPATHINFO>)
        {
          my(@hdiskInfo) = split(/ +/,$hdiskLine);
          my($hdisk) = substr($hdiskInfo[2],index($hdiskInfo[2],"/")+1);
          my($diskLine) = `/usr/bin/iostat|grep $hdisk`;
          my(@lineArray) = split(/ +/,$diskLine);
          $reads += $lineArray[4];
          $writes += $lineArray[5];
        }
      push(@diskArray,$vpathArr[0]."_read.value $reads\n",$vpathArr[0]."_write.value $writes\n");
    }
  return @diskArray;
}

sub printArray
{
  my($array,$spacer,$useNums,@labels) = @_;
  my($item,);
  my($count) = 0;

  foreach $item (@{$array})
    {
      if($useNums == 1)
        {print $count.substr($spacer,0,length($spacer)-length($count)).$item."\n";}
      else
        {print $labels[$count].substr($spacer,0,length($spacer)-length($labels[$count])).$item."\n";}
      $count++;
    }
}      
