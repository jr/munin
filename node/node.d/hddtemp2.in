#!@@PERL@@
#
# Plugin to monitor hard drive temperatures.
#
# This plugin is an alternative to the hddtemp_smartctl, which is the 
# preferred one.
#
# Requirements:
# 	- S.M.A.R.T. to be turned on for your hard drives
# 	- hddtemp program installed and in path
#
# Parameters supported:
#
# 	config
# 	autoconf
#
# Configurable variables
#
# 	hddtemp		- Override default program
# 	ignore		- Disks will not be touched
#                         "/dev/sdX /dev/sdY /dev/hdZ"
#
# Revision 0.1  2004/02/24 Andrew Radke
#
# $Log$
# Revision 1.8  2005/01/25 21:01:21  jimmyo
# Added plugin generic/hddtemp_smartctl, made by Lupe Christoph. Made it the default hddtemp plugin.
#
# Revision 1.7  2004/11/20 21:56:15  jimmyo
# Fixed bug in generic/hddtemp2, patch by arturaz (SF#1037002).
#
# Revision 1.6  2004/08/18 17:51:05  jimmyo
# Made generic/hddtemp2 understand environment variables with quotes (Deb#265022).
#
# Revision 1.5  2004/08/18 17:01:37  jimmyo
# Force LANG/LC_ALL=C in linux/sensors_ and generic/hddtemp2, to remove problems in parsing of sensors output (SF#972749, SF#972748, Deb#255312)
#
# Revision 1.4  2004/08/18 16:42:04  jimmyo
# Force LANG=C in plugin/hddtemp2, to remove problems in parsing of hddtemp output (Deb#253497).
#
# Revision 1.3  2004/05/20 19:02:36  jimmyo
# Set categories on a bunch of plugins
#
# Revision 1.2  2004/05/14 21:16:46  jimmyo
# "Upped" som plugins from contrib/manual to auto.
#
# Revision 1.1  2004/05/09 19:34:26  jimmyo
# Added plugin hddtemp2, contributred by Andrew Radke, modified by Lupe Christoph.
#
#
# Magic markers:
#%# family=contrib
#%# capabilities=autoconf

use strict;

$ENV{'LANG'} = "C"; # Hardcode lang so the hddtemp program to ease parsing of hddtemp-output.
$ENV{'LC_ALL'} = "C"; # Hardcode lang so the hddtemp program to ease parsing of hddtemp-output.
my $HDDTEMP = $ENV{'hddtemp'} || 'hddtemp';
my %config = (
	regex => qr/^\/dev\/([^:]+):\s*([^:]+):\s*([\d.]+) C/m,
	title => "Temperatures (Hard Disks)",
	vtitle => '°Celsius',
	warning => 50,
	critical => 60,
	graph_args => '--base 1000'
);

my @disks = (glob("/dev/hd?"), glob("/dev/sd?"));
if (exists $ENV{ignore}) {
  $ENV{ignore} =~ s/["']//g;
  my %ignore = map {$_ => 1} split(' ', $ENV{ignore});
  @disks = grep {! exists $ignore{$_} } @disks;
}

$HDDTEMP .= ' -q '.join(' ', @disks).' 2>/dev/null';

if ( exists $ARGV[0] and $ARGV[0] eq 'autoconf' ) {
  # Now see if "hddtemp" can run
  my $text = `$HDDTEMP`;
  if ($?) {
    if ($? == -1) {
      print "no (program $HDDTEMP not found)\n";
    } else {
      print "no (program $HDDTEMP died)\n";
    }
    exit 1;
  }

  unless ($text =~ / C/) {
    print "no (no temperature readings)\n";
    exit 1;
  }

  print "yes\n";
  exit 0;
}

if ( exists $ARGV[0] and $ARGV[0] eq 'config' ) {
  print "graph_title $config{title}\n";
  print "graph_vtitle $config{vtitle}\n";
  print "graph_args --base 1000\n";
  print "graph_category sensors\n";
  my $text = `$HDDTEMP`;
  while ($text =~ /$config{regex}/g) {
    my ($dev, $type, $temp) = ($1, $2, $3);
    $type =~ s/ {2,}/ /g;
    $type =~ s/ +$//g;
    print "hdd$dev.label $dev ($type)\n";
    print "hdd$dev.warning $config{warning}\n";
    print "hdd$dev.critical $config{critical}\n";
  }
  exit 0;
}

my $text = `$HDDTEMP`;
while ($text =~ /$config{regex}/g) {
  print "hdd$1.value $3\n";
}

# vim:syntax=perl
