#!@@PERL@@ -w
# -*- perl -*-

=head1 NAME

snmp__if_ - wildcard plugin to monitor network interfaces of any
networked equipment.

=head1 APPLICABLE SYSTEMS

Any SNMP capable networked computer equipment.  Using a command such
as "munin-node-configure --snmp switch.langfeldt.net --snmpversion 2c
--snmpcommunity public | sh -x" should auto-detect all applicable
interfaces.  On a typical switch you will get one plugin pr. ethernet
port.  On a router you might get one plugin pr. VLAN interface.

=CONFIGURATION

As a rule SNMP plugins need site specific configuration.  The default
configuration (shown here) will only work on insecure sites/devices:

   [snmp_*]
	env.version 2
        env.community public

The useMibEntryDescr setting enables using the interface's Description
value

In general SNMP is not very secure at all unless you use SNMP version
3 which supports authentication and privacy (encryption).  But in any
case the community string for your devices should not be "public".

Please see 'perldoc Munin::Plugin::SNMP' for further configuration
information.

=head1 INTERPRETATION

The graph shows a stright forward "bits per second" incomming and
outgoing thruput.  "Incomming" is towards the monitored device.

Note: The internal representation of the speeds is in bytes
pr. second.  The plugin multiplies everyting by 8 to get bits
pr. second.

=head1 MAGIC MARKERS

  #%# family=snmpauto
  #%# capabilities=snmpconf

=head1 VERSION

  $Id$

=head1 BUGS

None known.

=head1 AUTHOR

Copyright (C) 2004-2009 Jimmy Olsen, Daginn Ilmari Mannsaaker.
Documentation, porting to Munin::Plugin::SNMP and further grooming by
Nicolai Langfeldt.

Initial SNMPv3 support by "Confusedhacker".

=head1 LICENSE

GPLv2

=cut

use strict;
use Munin::Plugin;
use Munin::Plugin::SNMP;

my $DEBUG = $ENV{'MUNIN_DEBUG'};

my $response;
my $iface;

# This is the snmpwalk:
# .1.3.6.1.2.1.2.1.0 = INTEGER: 2
# .1.3.6.1.2.1.2.2.1.1.1 = INTEGER: 1
# .1.3.6.1.2.1.2.2.1.1.65539 = INTEGER: 65539
# .1.3.6.1.2.1.2.2.1.2.1 = STRING: MS TCP Loopback interface
# .1.3.6.1.2.1.2.2.1.2.65539 = STRING: Broadcom NetXtreme Gigabit Ethernet
# .1.3.6.1.2.1.2.2.1.3.1 = INTEGER: softwareLoopback(24)
# .1.3.6.1.2.1.2.2.1.3.65539 = INTEGER: ethernetCsmacd(6)
# .1.3.6.1.2.1.2.2.1.4.1 = INTEGER: 1520
# .1.3.6.1.2.1.2.2.1.4.65539 = INTEGER: 1500
# .1.3.6.1.2.1.2.2.1.5.1 = Gauge32: 10000000
# .1.3.6.1.2.1.2.2.1.5.65539 = Gauge32: 1000000000
# .1.3.6.1.2.1.2.2.1.6.1 = STRING:
# .1.3.6.1.2.1.2.2.1.6.65539 = STRING: 0:30:48:75:65:5e
# .1.3.6.1.2.1.2.2.1.7.1 = INTEGER: up(1)
# .1.3.6.1.2.1.2.2.1.7.65539 = INTEGER: up(1)
# .1.3.6.1.2.1.2.2.1.8.1 = INTEGER: up(1)
# .1.3.6.1.2.1.2.2.1.8.65539 = INTEGER: up(1)

if (defined $ARGV[0] and $ARGV[0] eq "snmpconf") {
	print "number  1.3.6.1.2.1.2.1.0\n";
	print "index   1.3.6.1.2.1.2.2.1.1.\n";
	print "require 1.3.6.1.2.1.2.2.1.3. ^(6|23)\$\n"; # Type
	print "require 1.3.6.1.2.1.2.2.1.5. [1-9]\n"; # Speed
	exit 0;
}

if ($Munin::Plugin::me =~ /_if_(\d+)$/) {
    $iface = $1;
} else {
    die "Could not determine interface number from ".$Munin::Plugin::me."\n";
}

my $ifEntryDescr     = "1.3.6.1.2.1.2.2.1.2.$iface";
my $ifEntryAlias     = "1.3.6.1.2.1.31.1.1.1.18.$iface";
my $ifEntrySpeed     = "1.3.6.1.2.1.2.2.1.5.$iface";
my $ifEntryStatus    = "1.3.6.1.2.1.2.2.1.8.$iface";
my $ifEntryInOctets  = "1.3.6.1.2.1.2.2.1.10.$iface";
my $ifEntryOutOctets = "1.3.6.1.2.1.2.2.1.16.$iface";
my $sysDescr         = '1.3.6.1.2.1.1.1.0';

my ($session, $error);

# SNMP needed for both config and fetch.
$session = Munin::Plugin::SNMP->session();

if ($ARGV[0] and $ARGV[0] eq "config") {
    my ($host) = Munin::Plugin::SNMP->config_session();

    print "host_name $host\n" unless $host eq 'localhost';

    my $alias = $session->get_single($ifEntryAlias) ||
      $session->get_single($ifEntryDescr) ||
	"Interface $iface";

    if (! ($alias =~ /\d+/) ) {
	# If there are no numbers in the $alias add the if index
	$alias .=" (if $iface)";
    }

    my $extrainfo = '';

    if (defined ($response = $session->get_single($ifEntryStatus))) {
	if ($response == 2) {
	    # Interface is down
	    $extrainfo .= ' The interface is currently down.'
	}
    }

    my $warn = undef;
    my $speed = undef;

    if (defined ($speed = $session->get_single($ifEntrySpeed))) {
	$warn = $speed/8;

	# Warn at 1/8th of actuall speed?  Or just remove warning?
	# Tempted to set warning at 80%. 80% over 5 minutes is pretty
	# busy.

	my $textspeed = scaleNumber($speed,,'bps','',
				   'The interface speed is %.1f%s%s.');

	$extrainfo .= " ".$textspeed if $textspeed;
    }

    print "graph_title Interface $alias traffic\n";
    print "graph_order recv send\n";
    print "graph_args --base 1000\n";
    print "graph_vlabel bits in (-) / out (+) per \${graph_period}\n";
    print "graph_category network\n";
    print "graph_info This graph shows traffic for the \"$alias\" network interface.$extrainfo\n";
    print "send.info Bits sent/received by this interface.\n";
    print "recv.label recv\n";
    print "recv.type DERIVE\n";
    print "recv.graph no\n";
    print "recv.cdef recv,8,*\n";
    print "recv.max $speed\n";
    print "recv.min 0\n";
    print "recv.warn ", (-$warn), "\n" if defined $warn;
    print "send.label bps\n";
    print "send.type DERIVE\n";
    print "send.negative recv\n";
    print "send.cdef send,8,*\n";
    print "send.max $speed\n";
    print "send.min 0\n";
    print "send.warn $warn\n" if defined $warn;
    exit 0;
}

if (defined ($response = $session->get_single($ifEntryStatus))) {
    if ($response == 2) {
	# Interface is down
	print "recv.value U\n";
	print "send.value U\n";
	exit 0;
    }
}

if (defined ($response = $session->get_single($ifEntryInOctets))) {
    print "recv.value ", $response, "\n";
} else {
    # No response...
    print "recv.value U\n";
}

if (defined ($response = $session->get_single($ifEntryOutOctets))) {
    print "send.value ", $response, "\n";
} else {
    # No response...
    print "send.value U\n";
}
