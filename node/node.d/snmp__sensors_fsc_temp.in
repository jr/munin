#!@@PERL@@ -w
#
# Copyright (C) 2004 Dagfinn Ilmari Mannsaaker
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2 dated June,
# 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Plugin to fetch temperature data from the ServerView SNMP agent on
# Fujitsu Simens servers
#
# $Log$
# Revision 1.5  2004/11/23 16:59:38  jimmyo
# Include SNMP.pm in the files. We don't want any perl modules in the node for the 1.2 series.
#
# Revision 1.4  2004/11/16 20:08:26  jimmyo
# License cleanups.
#
# Revision 1.3  2004/11/12 20:28:03  ilmari
# No debugging info by default
#
# Revision 1.2  2004/11/12 20:23:57  ilmari
# Rename Munin::Node::SNMP to Munin::Plugin::SNMP
#
# Revision 1.1  2004/10/27 18:58:26  ilmari
# Added SNMP plugins for Fujitsu Siemens ServerView temperature and fan sensors
#
#
#%# family=snmpauto
#%# capabilities=snmpconf

package Munin::Plugin::SNMP;

use Net::SNMP;
@ISA = qw(Net::SNMP);

sub session {
    my $class = shift;
    my $host      = $ENV{host}      || undef;
    my $port      = $ENV{port}      || 161;
    my $community = $ENV{community} || 'public';
    my $version   = $ENV{version}   || undef;

    if ($0 =~ /^(?:.*\/)?snmp_([^_]+)_/) {
	$host = $1;
	if ($host =~ /^([^:]+):(\d+)$/) {
	    $host = $1;
	    $port = $2;
	}
    } elsif (!defined($host)) {
	return unless wantarray; # Scalar or void context
	return (undef, 'Couldn not find monitoring target.'); # Array context
    }

    return $class->SUPER::session(-hostname  => $host,
				  -community => $community,
				  -port      => $port,
				  ($version ? (-version => $version) : ()));
}

sub get_hash {
    my $self = shift;
    my %args = @_;
    my %ret;
    
    my $base = $args{'-baseoid'};
    my $cols = delete $args{'-cols'} or return;

    my $table = $self->get_table(%args)
      or return;

    my $subtabs = join '|', keys %$cols;
    my $re = qr/^\Q$base.\E($subtabs)\.(.*)/;
    for my $key (keys %$table) {
	$key =~ $re;
	next unless defined($1 && $2);
	$ret{$2}{$cols->{$1}} = $table->{$key};
    }
    return \%ret;
}

package main;

use strict;
use Net::SNMP qw(oid_lex_sort);



# The OIDs we're after
my $tempBase = '1.3.6.1.4.1.231.2.10.2.2.5.2.1.1';

# Subtables
my $tempCabinetId          = 1;
my $tempSensorNumber       = 2;
my $tempSensorStatus       = 3;
my $tempSensorPurpose      = 4;
my $tempUpperWarningLevel  = 6;
my $tempUpperCriticalLevel = 8;
my $tempCurrentValue       = 11;
my $tempSensorDesignation  = 13;

# Magic values
my $tempSensorUnknown = 1;
my $tempSensorDisabled = 2;
my $tempSensorUnavailable = 99;

if (defined $ARGV[0] and $ARGV[0] eq 'snmpconf') {
    print "index   $tempBase.\n";
    # Require known, enabled and available sensors
    print "require $tempBase.$tempSensorStatus. ^[3-9]|[1-8][0-9]|9[0-8]\$\n";

    exit 0;
}

my $DEBUG = 0;

my ($session, $error) = Munin::Plugin::SNMP->session();

if ($error) {
    die "# Error: $error\n";
}

my $temps =  $session->get_hash(-baseoid => $tempBase,
				-cols    => { $tempCabinetId          => 'cabinet',
					      $tempSensorNumber       => 'number',
					      $tempSensorStatus       => 'status',
					      $tempSensorPurpose      => 'purpose',
					      $tempUpperWarningLevel  => 'warning',
					      $tempUpperCriticalLevel => 'critical',
					      $tempCurrentValue       => 'value',
					      $tempSensorDesignation  => 'label',
					    },
			       ) or die $session->error();

for my $key (keys %$temps) {
    my $temp = $temps->{$key};
    $temp->{info} = "Cabinet $temp->{cabinet} sensor $temp->{number}";
    # Delete sensors with status unknown, disabled or unavailable
    delete $temps->{$key}
      if $temp->{status} == $tempSensorUnknown ||
	$temp->{status} == $tempSensorDisabled ||
	$temp->{status} == $tempSensorUnavailable;
}

if (defined $ARGV[0] and $ARGV[0] eq 'config') {
    print <<EOM;
graph_title Temperatures
graph_args -l 0
graph_vlabel degrees Celcius
graph_category sensors
EOM
    print 'graph_order ', join(' ', map { get_id($_) } oid_lex_sort keys %$temps), "\n";
    print 'host_name ', $session->hostname(), "\n";
      
    for my $sensor (keys %$temps) {
	my $id = get_id($sensor);
	for my $key (qw(label warning critical info)) {
	    print "$id.$key $temps->{$sensor}->{$key}\n";
	}
	print "$id.type GAUGE\n";
    }
} else {
    print get_id($_), '.value ', $temps->{$_}{value}, "\n"
      for keys %$temps;
}

sub get_id {
    (my $id = shift) =~ tr/\./_/;
    return 'temp'.$id;
}
